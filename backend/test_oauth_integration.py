#!/usr/bin/env python3
"""
Testes de Integra√ß√£o OAuth2 - Mercado Livre

Suite de testes completa para validar implementa√ß√£o OAuth2 
seguindo todos os requisitos da documenta√ß√£o do Mercado Livre.

Inclui testes de:
- Configura√ß√£o PKCE
- Fluxo de autoriza√ß√£o
- Valida√ß√£o de tokens
- Seguran√ßa e rate limiting
- Middleware de seguran√ßa
- Auditoria e logging

Author: ML Project Team
Date: 2024
Version: 2.0.0
"""

import pytest
import asyncio
import aiohttp
import logging
from typing import Dict, Any, Optional
from pathlib import Path
import sys
import os

# Adicionar diret√≥rio backend ao path
backend_dir = Path(__file__).parent
sys.path.insert(0, str(backend_dir))

from app.core.mercadolivre_oauth import MercadoLivreConfig, PKCEConfig, SecurityLogger, RateLimiter
from app.services.mercadolivre_oauth import MercadoLivreOAuthService
from app.middleware.security import SecurityMiddleware, ValidationMiddleware
from app.settings import settings

# Configurar logging para testes
logging.basicConfig(level=logging.INFO)
logger = logging.getLogger(__name__)


class OAuth2IntegrationTests:
    """Suite de testes de integra√ß√£o OAuth2."""
    
    def __init__(self):
        self.config = MercadoLivreConfig()
        self.oauth_service = MercadoLivreOAuthService()
        self.security_logger = SecurityLogger("oauth_tests")
        self.results = {}
        
    async def test_pkce_generation(self) -> bool:
        """Testa gera√ß√£o e valida√ß√£o PKCE."""
        logger.info("üîê Testando gera√ß√£o PKCE...")
        
        try:
            # Gerar PKCE
            pkce = PKCEConfig.generate()
            
            # Valida√ß√µes b√°sicas
            assert len(pkce.code_verifier) >= 43, "Code verifier muito curto"
            assert len(pkce.code_verifier) <= 128, "Code verifier muito longo"
            assert len(pkce.code_challenge) > 0, "Code challenge vazio"
            assert pkce.code_challenge_method == "S256", "M√©todo incorreto"
            
            # Validar que challenge √© diferente do verifier
            assert pkce.code_challenge != pkce.code_verifier, "Challenge igual ao verifier"
            
            # Gerar m√∫ltiplos PKCEs e verificar unicidade
            pkce2 = PKCEConfig.generate()
            assert pkce.code_verifier != pkce2.code_verifier, "PKCEs n√£o √∫nicos"
            assert pkce.code_challenge != pkce2.code_challenge, "Challenges n√£o √∫nicos"
            
            logger.info("‚úÖ PKCE gera√ß√£o e valida√ß√£o OK")
            return True
            
        except Exception as e:
            logger.error(f"‚ùå Erro no teste PKCE: {e}")
            return False
    
    async def test_oauth_urls(self) -> bool:
        """Testa gera√ß√£o de URLs OAuth."""
        logger.info("üîó Testando URLs OAuth...")
        
        try:
            # Gerar PKCE para teste
            pkce = PKCEConfig.generate()
            state = "test_state_123"
            
            # Gerar URL de autoriza√ß√£o
            auth_url = self.oauth_service.get_auth_url(state, pkce.code_challenge)
            
            # Valida√ß√µes da URL
            assert "https://auth.mercadolibre.com.br/authorization" in auth_url, "URL base incorreta"
            assert f"client_id={settings.ml_client_id}" in auth_url, "Client ID ausente"
            assert f"redirect_uri={settings.ml_redirect_uri}" in auth_url, "Redirect URI ausente"
            assert "response_type=code" in auth_url, "Response type incorreto"
            assert f"state={state}" in auth_url, "State ausente"
            assert f"code_challenge={pkce.code_challenge}" in auth_url, "Code challenge ausente"
            assert "code_challenge_method=S256" in auth_url, "Challenge method ausente"
            
            logger.info("‚úÖ URLs OAuth gera√ß√£o OK")
            return True
            
        except Exception as e:
            logger.error(f"‚ùå Erro no teste URLs: {e}")
            return False
    
    async def test_rate_limiting(self) -> bool:
        """Testa sistema de rate limiting."""
        logger.info("üö¶ Testando rate limiting...")
        
        try:
            rate_limiter = RateLimiter(max_requests=3, window_seconds=1)
            client_ip = "192.168.1.100"
            
            # Primeiro request deve passar
            assert rate_limiter.is_allowed(client_ip), "Primeiro request bloqueado"
            
            # Segundo request deve passar
            assert rate_limiter.is_allowed(client_ip), "Segundo request bloqueado"
            
            # Terceiro request deve passar
            assert rate_limiter.is_allowed(client_ip), "Terceiro request bloqueado"
            
            # Quarto request deve ser bloqueado
            assert not rate_limiter.is_allowed(client_ip), "Rate limit n√£o funcionando"
            
            # Aguardar reset
            await asyncio.sleep(1.1)
            
            # Deve funcionar novamente
            assert rate_limiter.is_allowed(client_ip), "Rate limit n√£o resetou"
            
            logger.info("‚úÖ Rate limiting funcionando")
            return True
            
        except Exception as e:
            logger.error(f"‚ùå Erro no teste rate limiting: {e}")
            return False
    
    async def test_security_logging(self) -> bool:
        """Testa sistema de logging de seguran√ßa."""
        logger.info("üìù Testando logging de seguran√ßa...")
        
        try:
            # Log de evento de seguran√ßa
            self.security_logger.log_security_event(
                event_type="oauth_login_attempt",
                user_id="test_user",
                ip_address="192.168.1.100",
                details={"client_id": "test_client"}
            )
            
            # Log de viola√ß√£o
            self.security_logger.log_security_violation(
                violation_type="rate_limit_exceeded",
                ip_address="192.168.1.200",
                details={"requests_count": 150}
            )
            
            # Log de auditoria
            self.security_logger.log_audit_event(
                action="token_refresh",
                user_id="test_user",
                resource="oauth_token",
                details={"token_id": "test_token_123"}
            )
            
            logger.info("‚úÖ Security logging funcionando")
            return True
            
        except Exception as e:
            logger.error(f"‚ùå Erro no teste logging: {e}")
            return False
    
    async def test_token_validation(self) -> bool:
        """Testa valida√ß√£o de tokens (mock)."""
        logger.info("üé´ Testando valida√ß√£o de tokens...")
        
        try:
            # Simular token v√°lido
            valid_token = {
                "access_token": "APP_USR-123456789-test-token-here",
                "token_type": "Bearer",
                "expires_in": 21600,
                "scope": "offline_access read write",
                "user_id": 123456789,
                "refresh_token": "TG-123456789-test-refresh-token"
            }
            
            # Valida√ß√µes b√°sicas do token
            assert "access_token" in valid_token, "Access token ausente"
            assert "refresh_token" in valid_token, "Refresh token ausente"
            assert valid_token["token_type"] == "Bearer", "Token type incorreto"
            assert valid_token["expires_in"] > 0, "Expira√ß√£o inv√°lida"
            assert isinstance(valid_token["user_id"], int), "User ID inv√°lido"
            
            # Validar formato do access token ML
            access_token = valid_token["access_token"]
            assert access_token.startswith("APP_USR-"), "Formato de token ML incorreto"
            assert len(access_token) > 20, "Token muito curto"
            
            logger.info("‚úÖ Valida√ß√£o de tokens OK")
            return True
            
        except Exception as e:
            logger.error(f"‚ùå Erro no teste token validation: {e}")
            return False
    
    async def test_error_handling(self) -> bool:
        """Testa tratamento de erros OAuth."""
        logger.info("‚ö†Ô∏è Testando tratamento de erros...")
        
        try:
            # Testar erro de autoriza√ß√£o negada
            error_response = {
                "error": "access_denied",
                "error_description": "The user denied the request"
            }
            
            error_handled = self.oauth_service.handle_oauth_error(error_response)
            assert error_handled is not None, "Erro n√£o tratado"
            
            # Testar erro de c√≥digo inv√°lido
            invalid_code_error = {
                "error": "invalid_grant",
                "error_description": "Invalid authorization code"
            }
            
            error_handled = self.oauth_service.handle_oauth_error(invalid_code_error)
            assert error_handled is not None, "Erro de c√≥digo inv√°lido n√£o tratado"
            
            logger.info("‚úÖ Tratamento de erros funcionando")
            return True
            
        except Exception as e:
            logger.error(f"‚ùå Erro no teste error handling: {e}")
            return False
    
    async def test_security_headers(self) -> bool:
        """Testa cabe√ßalhos de seguran√ßa."""
        logger.info("üõ°Ô∏è Testando headers de seguran√ßa...")
        
        try:
            # Simular headers de seguran√ßa esperados
            expected_headers = {
                "X-Content-Type-Options": "nosniff",
                "X-Frame-Options": "DENY", 
                "X-XSS-Protection": "1; mode=block",
                "Strict-Transport-Security": "max-age=31536000; includeSubDomains",
                "Content-Security-Policy": "default-src 'self'",
                "Referrer-Policy": "strict-origin-when-cross-origin"
            }
            
            # Validar que todos os headers necess√°rios est√£o definidos
            for header, value in expected_headers.items():
                assert header is not None, f"Header {header} n√£o definido"
                assert value is not None, f"Valor do header {header} n√£o definido"
            
            logger.info("‚úÖ Security headers OK")
            return True
            
        except Exception as e:
            logger.error(f"‚ùå Erro no teste security headers: {e}")
            return False
    
    async def test_environment_validation(self) -> bool:
        """Testa valida√ß√£o do ambiente."""
        logger.info("üåç Testando valida√ß√£o de ambiente...")
        
        try:
            # Verificar configura√ß√µes obrigat√≥rias
            config_checks = {
                "ml_client_id": bool(settings.ml_client_id.strip()),
                "ml_client_secret": bool(settings.ml_client_secret.strip()),
                "ml_redirect_uri": bool(settings.ml_redirect_uri.strip()),
                "secret_key": settings.secret_key != "change-this-secret-key-in-production",
                "oauth_config": settings.validate_oauth_config()
            }
            
            # Log dos resultados
            for check, result in config_checks.items():
                if result:
                    logger.info(f"‚úÖ {check}: OK")
                else:
                    logger.warning(f"‚ö†Ô∏è {check}: FALHOU")
            
            # Verificar pa√≠ses suportados
            supported_countries = ["MLB", "MLA", "MLM", "MCO", "MLC", "MLU", "MLV", "MPE", "MBO"]
            assert settings.ml_default_country in supported_countries, f"Pa√≠s n√£o suportado: {settings.ml_default_country}"
            
            logger.info("‚úÖ Valida√ß√£o de ambiente OK")
            return all(config_checks.values())
            
        except Exception as e:
            logger.error(f"‚ùå Erro no teste environment: {e}")
            return False
    
    async def run_all_tests(self) -> Dict[str, bool]:
        """Executa todos os testes de integra√ß√£o."""
        logger.info("üß™ INICIANDO TESTES DE INTEGRA√á√ÉO OAUTH2")
        logger.info("="*60)
        
        tests = [
            ("PKCE Generation", self.test_pkce_generation),
            ("OAuth URLs", self.test_oauth_urls),
            ("Rate Limiting", self.test_rate_limiting),
            ("Security Logging", self.test_security_logging),
            ("Token Validation", self.test_token_validation),
            ("Error Handling", self.test_error_handling),
            ("Security Headers", self.test_security_headers),
            ("Environment Validation", self.test_environment_validation),
        ]
        
        results = {}
        passed = 0
        total = len(tests)
        
        for test_name, test_func in tests:
            logger.info(f"\nüìã Executando: {test_name}")
            try:
                result = await test_func()
                results[test_name] = result
                if result:
                    passed += 1
                    logger.info(f"‚úÖ {test_name}: PASSOU")
                else:
                    logger.error(f"‚ùå {test_name}: FALHOU")
            except Exception as e:
                logger.error(f"üí• {test_name}: ERRO - {e}")
                results[test_name] = False
        
        # Resumo final
        logger.info("\n" + "="*60)
        logger.info("üìä RESUMO DOS TESTES")
        logger.info("="*60)
        logger.info(f"‚úÖ Passou: {passed}/{total}")
        logger.info(f"‚ùå Falhou: {total - passed}/{total}")
        logger.info(f"üìà Taxa de sucesso: {(passed/total)*100:.1f}%")
        
        if passed == total:
            logger.info("\nüéâ TODOS OS TESTES PASSARAM!")
            logger.info("Sistema OAuth2 est√° funcionando corretamente.")
        else:
            logger.warning(f"\n‚ö†Ô∏è {total - passed} TESTE(S) FALHARAM!")
            logger.warning("Verifique as configura√ß√µes e depend√™ncias.")
        
        return results


async def main():
    """Fun√ß√£o principal para executar testes."""
    print("üîê TESTES DE INTEGRA√á√ÉO OAUTH2 - MERCADO LIVRE")
    print("Vers√£o 2.0.0 - Compat√≠vel com todas as exig√™ncias ML\n")
    
    # Verificar se ambiente est√° configurado
    if not settings.validate_oauth_config():
        print("‚ö†Ô∏è Configura√ß√£o OAuth incompleta!")
        print("Execute primeiro: python setup_oauth.py")
        return False
    
    # Executar testes
    test_suite = OAuth2IntegrationTests()
    results = await test_suite.run_all_tests()
    
    # Retornar sucesso geral
    all_passed = all(results.values())
    return all_passed


if __name__ == "__main__":
    try:
        success = asyncio.run(main())
        sys.exit(0 if success else 1)
    except KeyboardInterrupt:
        print("\n\n‚ùå Testes cancelados pelo usu√°rio.")
        sys.exit(1)
    except Exception as e:
        print(f"\n‚ùå Erro inesperado nos testes: {e}")
        sys.exit(1)
